//
//  ArtboardRepresentable.swift
//  Salsa
//
//  Created by Max Rabiciuc on 8/14/17.
//  Copyright Â© 2017 Yelp. All rights reserved.
//

import UIKit

/// A tuple of a UIView and a name for that view
public typealias ArtboardElement = (view: UIView, name: String)

/// Conform your `UIView` to this protocol to easily create an `Artboard` for your example views
/// Provide example views using the artboardElements() method and create an artboard by calling `makeArtboard(origin:)`
public protocol ArtboardRepresentable {

  /// The only required method that needs to be implemented
  /// Returns vertical stacks of ArtboardElements
  static func artboardElements() -> [[ArtboardElement]]

  /// Name of the artboard.
  static var name: String { get }

  /// Fixed width to use for views provided in artboardElements()
  /// Set to nil to have the view be self sized
  static var viewWidth: CGFloat? { get }

  /// Insets to the edges of the artboard
  static var artboardInsets: UIEdgeInsets { get }

  /// Spacing between artboard elements
  static var artboardSpacing: CGFloat { get }

  /// Background color of the artboard
  static var artboardColor: Color { get }

  /// Generates an `Artboard` containing examples of the conforming type
  static func makeArtboard(origin: CGPoint) -> Artboard
}

extension ArtboardRepresentable {
  /// Defaults to the name of self
  public static var name: String { return String(describing: self) }
  /// Defaults to the screen width
  public static var viewWidth: CGFloat? { return UIScreen.main.bounds.width }
  /// Defaults to .zero
  public static var artboardInsets: UIEdgeInsets { return .zero }
  /// Defaults to 8
  public static var artboardSpacing: CGFloat { return 8 }
  /// Defaults to #F5F5F5
  public static var artboardColor: Color { return UIColor(white: 245/255.0, alpha: 1.0).makeSketchColor() }

  /**
   Creates an artboard using the elements provided in `artboardElements()`.

   Views provided in `artboardElements()` will be automatically laid out

   Each set of `ArtboardElement` will be stacked vertically inside the `Artboard`

   - parameter origin:            Origin of the first `Artboard` within the page
   */
  public static func makeArtboard(origin: CGPoint) -> Artboard {
    let views: [Group] = makeGroups(startingOrigin: CGPoint(x: artboardInsets.left, y: artboardInsets.top))
    return makeArtboard(origin: origin, layers: views)
  }

  fileprivate static func makeArtboard(origin: CGPoint, layers: [Layer]) -> Artboard {
    var width: CGFloat = 0
    var height: CGFloat = 0
    layers.forEach {
      height = max(height, $0.frame.bottom)
      width = max(width, $0.frame.right)
    }
    width += artboardInsets.right
    height += artboardInsets.bottom
    return Artboard(name: name, layers: layers, frame: CGRect(x: origin.x, y: origin.y, width: width, height: height), color: artboardColor)
  }
}

/**
 Creates an `Artboard` and `SymbolMasters` out of elements provided by `artboardElements()`.

 The `Artboard` created by `makeArtboard(origin:)` contain layers of type `SymbolInstance`

 The `SymbolMasters` created by `makeSymbols(startingOrigin:exportDictionary:)` must be present somewhere in the `Document`
 */
public protocol SymbolRepresentable: ArtboardRepresentable {
  /**
   Generates `SymbolMasters` that represent the conforming type

   - parameter startingOrigin:    Origin of the first `SymbolMaster` in the list
   */
  static func makeSymbols(startingOrigin: CGPoint) -> [SymbolMaster]
}

extension SymbolRepresentable {
  /// Creates a set of `SymbolMaster` out of the elements provided in `artboardElements()`
  ///
  /// `SymbolMaster` elements are laid out in the same fashion as they are inside the `Artboard` generated by `makeArtboard(origin:)`
  public static func makeSymbols(startingOrigin: CGPoint) -> [SymbolMaster] {
    return makeGroups(startingOrigin: startingOrigin).map { view in
      let frame = view.frame
      view.frame = CGRect(origin: .zero, size: frame.size)
      return SymbolMaster(name: view.name, frame: frame, layers: [view])
    }
  }

  public static func makeArtboard(origin: CGPoint) -> Artboard {
    let symbolInstances: [SymbolInstance] = makeSymbols(startingOrigin: CGPoint(x: artboardInsets.left, y: artboardInsets.top)).map { SymbolInstance(name: $0.name, frame: $0.frame) }
    return makeArtboard(origin: origin, layers: symbolInstances)
  }
}

// MARK: Private
fileprivate extension ArtboardRepresentable {
  /// Performs layout on all the views provided in artboardElements and turns them into Groups
  static func makeGroups(startingOrigin: CGPoint) -> [Group] {
    var x: CGFloat = startingOrigin.x
    let groups: [[Group]] = artboardElements().map { elementStack in
      var y: CGFloat = startingOrigin.y
      var newX: CGFloat = x
      let stack: [Group] = elementStack.map { element in
        let view = element.view
        view.translatesAutoresizingMaskIntoConstraints = false

        // Give the view a fixed width if needed
        let widthConstraint: NSLayoutConstraint? = {
          if let width = viewWidth {
            return view.widthAnchor.constraint(equalToConstant: width)
          }
          return nil
        }()

        // Figure out the natural size of the view
        widthConstraint?.isActive = true
        let size = view.systemLayoutSizeFitting(UILayoutFittingCompressedSize)
        widthConstraint?.isActive = false
        view.translatesAutoresizingMaskIntoConstraints = true

        // Set the view's frame to match its natural size and perform layout
        view.frame = CGRect(origin: CGPoint(x: x, y: y), size: size)
        view.setNeedsLayout()
        view.layoutIfNeeded()

        // Unless the view's background was explicitly set to .clear we assume that it should be .white
        if view.backgroundColor == nil {
          view.backgroundColor = .white
        }

        // Create a Group
        var group = view.makeSketchGroup()

        // Set a better name for the Group
        let name = "\(self.name)/\(element.name)"
        group = Group(frame: group.frame, layers: group.layers, alpha: group.alpha, name: name, shadow: group.shadow)

        // Update position in the artboard for the next element
        y = group.frame.bottom + artboardSpacing
        newX = max(newX, group.frame.right + artboardSpacing)

        return group
      }
      x = newX
      return stack
    }
    return groups.flatMap { $0 }
  }
}

/// Creates laid out artboards and symbols for the given `ArtboardRepresentable` types
/// - parameter providers: Array of columns of artboards. i.e. [[a], [b]] will layout a and b side by side while [[a, b]] will layout a and b vertically. Providers that conform to `SymbolRepresentable` will also produce `SymbolMasters`. These will follow the same layout rules as artboards
/// - parameter padding: Padding between neighboring artbords and symbols
public func makeArtboardsAndSymbols(from providers: [[ArtboardRepresentable.Type]], padding: CGFloat = 80) -> (artboards: [Artboard], symbols: [SymbolMaster]) {
  let symbolProviders: [[SymbolRepresentable.Type]] = providers.map { innerProviders in
    return innerProviders.compactMap { $0 as? SymbolRepresentable.Type }
  }
  return (
    artboards: makeArtboards(from: providers, padding: padding),
    symbols: makeSymbols(from: symbolProviders, padding: padding)
  )
}

private func makeArtboards(from providers: [[ArtboardRepresentable.Type]], padding: CGFloat) -> [Artboard] {
  var x: CGFloat = 0
  let artboards: [[Artboard]] = providers.map { stack in
    var y: CGFloat = 0
    var newX = x
    let artboards: [Artboard] = stack.map {
      let artboard = $0.makeArtboard(origin: CGPoint(x: x, y: y))
      y = artboard.frame.bottom + padding
      newX = max(newX, artboard.frame.right)
      return artboard
    }
    x = newX + padding

    return artboards
  }
  return artboards.flatMap { $0 }
}

private func makeSymbols(from providers: [[SymbolRepresentable.Type]], padding: CGFloat) -> [SymbolMaster] {
  var x: CGFloat = 0
  let symbols: [[[SymbolMaster]]] = providers.map { stack in
    var y: CGFloat = 0
    var newX = x
    let symbolSet: [[SymbolMaster]] = stack.map {
      let symbols: [SymbolMaster] = $0.makeSymbols(startingOrigin: CGPoint(x: x, y: y))
      symbols.forEach {
        newX = max(newX, $0.frame.right)
        y = max(y, $0.frame.bottom)
      }
      y += padding
      return symbols
    }
    x = newX + padding
    return symbolSet
  }
  return symbols.flatMap({ $0 }).flatMap({ $0 })
}

